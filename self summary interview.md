-------------------

## golang

### go gc 

开始: 标记清楚法, 每次清理垃圾时都要STW对性能影响较大

三色标记法: 由黑色, 灰色, 白色组成, 在开始gc时, 所有对象为白色, 扫描由堆栈根节点出发扫描一层对象, 将其标为灰色, 后面gc只扫描灰色对象, 将已扫描的灰色对象置为黑色, 直到没有灰色对象, 就清除白色垃圾

​	引发的问题: 当一个灰色对象删除了一个白色对象的引用, 而黑色对象引用了这个白色对象, 那这个白色对象就会被清除

​	为解决这个问题: 引入强弱三色不变式

​	强三色不变式: 不存在黑色对象引用到白色对象的指针

​		插入屏障(栈上不使用): 堆上黑色对象引用白色对象时, 将白色对象置灰, 而栈上在gc结束之前使用stw重新扫描栈上对象

​	弱三色不变式: 被黑色对象引用的白色对象的上游有灰色对象保护

​		删除屏障: 当删除对象时, 如果对象为灰色或白色则置灰, 当轮不删除(gc效率低)

三色标记与混合屏障: 

1. 将栈上可达对象均置为黑色, 后续新建的栈上对象均为黑色
2. 后续删除与被添加的对象均标记为灰色









### go gmp

g: golang 语言层面的协程

m: mechine 对应一个内核线程

p: processer 处理队列

全局队列

通过 gomaxprocs 控制 p 的数量, 也是程序最高并行量

开始的gm模型: 多个 m 抢占一个全局 goroutine 队列(激烈的锁竞争, 性能低下)

**设计策略:**

- 复用线程:
    - working stealing 机制: 当一个 p 队列没有goroutine时首先偷取其余队列的 g(偷后一半), 偷不到从全局队列拿(但自旋线程首先从全局队列去取)
    - hand off 机制: 当 g 阻塞时, g 会与 m 绑定, m 与 p 解绑, p 会寻找空闲 m
- 并行: 设置 gomaxprocs 控制 p 的数量
- 抢占: 每个 g 最多运行 10ms



从阻塞状态恢复的 m, 会试图与 原始的 p 尝试绑定失败从空闲 p 队列获取, 成功允许 g, 失败将 g 加入全局队列



每个 m 都有一个 g0, 其中 g0 只用于调度

每个程序都会有一个 m0, m0 负责启动第一个 g, 后续就和其余 m 相同









### go func()  调度流程

- 通过 go func() 新建一个 goroutine, 新建的 g 会根据局部性优先加入本地 p 队列, 如果本地 p 队列已满, 打乱 p 前一半顺序后与 新建 g 一起加入全局队列
- 在 p 队列重复调度, 直到 g 完成
- 状态: 调度 -> 执行/阻塞 -> 销毁 -> 再次进入 p 本地队列













### go slice array













### go map













### jwt 数据结构













### append() 原理











### make() 和 new() 区别

new() : 会为类型分配一份内存空间, 并将值置为零值

make() : 同样用于内存分配(常用于 chan, map, slice) 

go 编译器会尽量将对象分配到栈上, 如果变量未逃逸, 就在栈上分配, 否则在堆上分配, 如果对象过大, 会分配到堆上



### 内存逃逸

- 如果超出对象的指针生命周期, 会逃逸到堆(使用指针变量, 引用对象等)
- 栈对象指针不能指向堆对象







### go 引用类型

储存的不是数据本身而是指向底层数据结构的指针

例如: slice, map, channel













----------------------

## kubernetes

### etcd









### k8s 优势









### iptables 和 ipvs 原理与区别













### pod 一直 crash

https://www.cnblogs.com/alisystemsoftware/p/16919263.html









---------------------

## istio

### 如何注入 sidecar









### envoy 如何接管 pod 中容器的流量





















----------------------

## 操作系统

### 介绍进程和线程, 区别

进程: 是资源管理的基本单元, 可以有一个或多个线程

线程: 是程序运行的基本单元

区别:

切换: 线程的上下文切换远远快于进程(内核栈与硬件上下文)

拥有资源: 每个进程都有操作系统分配的独立虚拟空间, 而同一个进程下的线程共享进程资源

系统开销: 进程的创建与销毁开销也远远大于线程的开销



进程切换耗时: 进程切换需要切换虚拟内存, 那页表也会切换, 那 tlb 缓存中页表也会失效, 而线程切换就无需设计页表切换





### 进程调度

- 先来先服务
- 短作业优先
- 最短剩余时间优先
- 时间片轮转: 注意时间片大小
- 优先级调度(高响应比调度): 为进程分配优先级, 等待时间越长优先级越高





### 进程状态

- 创建

- 就绪: 所需系统资源充足, 等待cpu时间片
- 运行
- 阻塞: i/o 请求
- 结束









### 多进程多线程模型

单进程: 所有进程只有线性处理, 当前面的进程阻塞时, 后续线程同样会阻塞

多进程: 一个cpu来看, 当一个进程发送阻塞时, cpu会立即切换到其他进程, 并且可根据相应的调度算法确保每个进程可被分配到cpu时间片, 也就可做到宏观上多个进程同时进行

​	-> 可引入内核线程, 用户态线程

协程调度器: 也可理解为一个用户态线程, 会绑定一个内核线程, 用于调度协程

内核线程 : 协程(协程需要主动释放控制权)

1:n : 会出现当一个协程阻塞时, 会阻塞其余后续协程的调度

1:1 : 协程的创建、删除和切换的代价都由CPU完成，有点略显昂贵了

m:n : 多个内核线程绑定一个协程调度器, 关键在于协程调度器的设计, 设计复杂

另外就是 golang 的gmp模型













### 进程间的通信方式

- 管道: 匿名管道和命名管道  (半双工 - 单向通信)
    - 匿名管道: 当创建一个匿名管道时会在内核缓存区开辟一块空间, 往往用于具有亲密关系的进程间通信
    - 命名管道: 在磁盘中真实存在的一个文件, 可以实现
- 信号
- 信号量   --  类似于锁机制
- 消息队列
- 共享内存
- socket
- 文件











### 进程/线程间的同步方式

- 临界区  --  只允许同时有一个进程进入临界区

- 互斥量
- 信号量
- 事件













### 乐观锁与悲观锁

- 悲观锁: 
- 乐观锁: 















### 分页和分段















### 页面替换算法

















### I/O 多路复用















----------------------

## linux



























----------------------

## 计算机网络

### tcp 三次握手四次挥手









### tcp 重传机制











### tcp 拥塞控制



































----------------------

## mysql



### 隔离级别

- 读未提交
- 读已提交(rc)
- 可重复读(rr)
- 串行化





### innodb 数据

表空间 -> 分段 -> 分区 -> 页(page)

所有数据都存放在 page (索引, 数据等), 一个 page 16k







### 索引













### mvcc 多版本并发控制

*只作用于 rc, rr*

每张表都有两个隐藏字段: tx_id, roll_id, role_ptr

read view: 结构体

- 活跃事务id列表
- 最小活跃事务id
- 预分配事务id
- 当前事务id

read view 在 rc 下:

当











### 手写 sql 























----------------------

## redis

### redis 为什么快

















































